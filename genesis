#!/usr/bin/env python3

import argparse
import itertools
import multiprocessing
import os
import os.path
import re
import shlex
import subprocess
import sys

#
# Globals
#

PROGRAM = sys.argv[0]
ARGV = sys.argv[1:]

# Default values for command line options.
BOARD_DEFAULT = '96b_nitrogen'
CONF_FILE_DEFAULT = 'prj.conf'
BUILD_PARALLEL_DEFAULT = multiprocessing.cpu_count()
MCUBOOT_DEV_KEY = 'root-rsa-2048.pem'     # Development-only signing key.
MCUBOOT_IMGTOOL_VERSION_DEFAULT = '0.0.0'
CONFIGURATOR_DEFAULT = 'menuconfig'

# Other default values.
BUILD_DIR_DEFAULT = 'outdir'              # relative to genesis root.

# Checked out paths for important repositories relative to Genesis root.
# TODO: parse these from the repo manifest, for robustness, at some point.
ZEPHYR_PATH = 'zephyr'
ZEPHYR_SDK_PATH = os.path.join('sdk-prebuilts', 'zephyr-sdk')
MCUBOOT_PATH = 'mcuboot'

# We could be smarter about this (search for .repo, e.g.), but it seems
# unnecessary.
GENESIS_ROOT = os.path.abspath(os.path.dirname(__file__))

# Build configuration from command line options that overrides environment
# variables.
BUILD_OPTIONS = ['board', 'conf_file']
# Build configuration from internal values that overrides env. variables.
# TODO: override SDK install dir when we can provide a prebuilt repository.
BUILD_OVERRIDES = ['zephyr_base',
                   'zephyr_gcc_variant',
                   # 'zephyr_sdk_install_dir'
                   ]

# What types of build outputs to produce.
# - app: Genesis application, which can be signed for flashing or FOTA update.
# - mcuboot: Genesis bootloader, not signed and must be flashed.
BUILD_OUTPUTS = ['app', 'mcuboot']

# imgtool.py state. This post-processes binaries for chain-loading by mcuboot.
IMGTOOL = os.path.join('scripts', 'imgtool.py')

# mcuboot-related board-specific state.
#
# FIXME: there are too many copies of this information.
#
# All of this configuration really needs to live in one place (not here), and
# to get propagated to each application and mcuboot's own build systems at
# "configuration" time.
MCUBOOT_BOARD_INFO = {
    '96b_nitrogen': {
        'vtoff': 0x100,
        'word-size': 4,
        'pad': 0x34000,
    },

    '96b_carbon': {
        'vtoff': 0x100,
        'word-size': 1,
        'pad': 0x20000,
    },

    'frdm_k64f': {
        'vtoff': 0x200,
        'word-size': 8,
        'pad': 0x60000,
    },

    'nrf52840_pca10056': {
        'vtoff': 0x100,
        'word-size': 4,
        'pad': 0x6c000,
    },
}

CONFIGURATORS = ['config', 'nconfig', 'menuconfig', 'xconfig', 'gconfig',
                 'oldconfig', 'silentoldconfig', 'defconfig', 'savedefconfig',
                 'allnoconfig', 'allyesconfig', 'alldefconfig', 'randconfig',
                 'listnewconfig', 'olddefconfig']


#
# Path management
#


def find_genesis_root():
    '''Get absolute path of root directory of this Genesis installation.'''
    return GENESIS_ROOT


def find_zephyr_base():
    '''Get absolute path of Genesis Zephyr base directory.'''
    return os.path.join(find_genesis_root(), ZEPHYR_PATH)


def find_zephyr_sdk():
    '''Get absolute path of Genesis Zephyr SDK.'''
    return os.path.join(find_genesis_root(), ZEPHYR_SDK_PATH)


def find_app_root(app_name):
    '''Get absolute path of app within Genesis Zephyr SDK.'''
    return os.path.join(find_genesis_root(), app_name)


def find_mcuboot_root():
    '''Get absolute path of mcuboot repository.'''
    return os.path.join(find_genesis_root(), MCUBOOT_PATH)


def find_default_outdir():
    '''Get absolute path of default output directory.'''
    return os.path.join(find_genesis_root(), BUILD_DIR_DEFAULT)


#
# Common arguments
#


class CommonArguments(object):
    '''Helper class for arguments which are taken by multiple commands.'''

    ARG_HELP = {
        # Generally useful.
        '--board': '''Zephyr board to target
                   (default: {})'''.format(BOARD_DEFAULT),
        '--outdir': '''Build directory (default: '{}' under Genesis
                    root).'''.format(BUILD_DIR_DEFAULT),
        'app': 'Genesis application(s) sources',

        # Needed to build, configure, etc. Zephyr.
        '--conf-file': '''App (not mcuboot) configuration file
                       (default: {})'''.format(CONF_FILE_DEFAULT),
        '--jobs': '''Number of jobs to run simultaneously (default: number of
                   available CPUs)''',
        '--keep-going': '''If set, keep running after the first build failure.
                         Otherwise, exit on the first failure, with failing
                         command's exit code.''',
        '--outputs': 'Which outputs to target (default: all)',
        }

    @staticmethod
    def _whitelist(whitelist):
        if whitelist is None:
            return CommonArguments.ARG_HELP.keys()
        else:
            for arg in whitelist:
                if arg not in CommonArguments.ARG_HELP:
                    msg = 'internal error: unknown argument {}'.format(arg)
                    raise ValueError(msg)
            return whitelist

    @staticmethod
    def add_arguments(parser, help_overrides={}, whitelist=None):
        arg_help = dict(CommonArguments.ARG_HELP)
        arg_help.update(help_overrides)

        whitelist = CommonArguments._whitelist(whitelist)

        # These are generally useful for commands that operate on build
        # artifacts.
        if '--board' in whitelist:
            parser.add_argument('-b', '--board',
                                default=BOARD_DEFAULT,
                                help=arg_help['--board'])
        if '--outdir' in whitelist:
            parser.add_argument('-O', '--outdir',
                                default=find_default_outdir(),
                                help=arg_help['--outdir'])
        if 'app' in whitelist:
            parser.add_argument('app', nargs='+', help=arg_help['app'])

        # These are needed by commands that invoke 'make', like 'build' and
        # 'configure'.
        if '--conf-file' in whitelist:
            parser.add_argument('-c', '--conf-file',
                                default=CONF_FILE_DEFAULT,
                                help=arg_help['--conf-file'])
        if '--jobs' in whitelist:
            parser.add_argument('-j', '--jobs',
                                type=int, default=BUILD_PARALLEL_DEFAULT,
                                help=arg_help['--jobs'])
        if '--keep-going' in whitelist:
            parser.add_argument('-k', '--keep-going',
                                action='store_true',
                                help=arg_help['--keep-going'])
        if '--outputs' in whitelist:
            parser.add_argument('-o', '--outputs',
                                choices=BUILD_OUTPUTS + ['all'],
                                default='all',
                                help=arg_help['--outputs'])


#
# Make helpers
#


def make_warn_override(args, arg):
    arg_val = getattr(args, arg)
    env_var = arg.upper()
    if env_var in os.environ and arg_val != os.environ[env_var]:
        print('Warning: overriding {}:'.format(env_var),
              file=sys.stderr)
        print('\tenvironment value: {}'.format(os.environ[env_var]),
              file=sys.stderr)
        print('\tbuilding with:     {}'.format(arg_val),
              file=sys.stderr)


def make_warn_overrides(args):
    '''Warn on values overridden from the environment.

    Looks for environment variables relevant to the Zephyr or
    application build (BOARD, etc.), and warns on values that are
    overridden by Genesis.'''
    for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
        make_warn_override(args, b)


def make_do_overrides(args):
    if args.outputs == 'all':
        args.outputs = BUILD_OUTPUTS
    else:
        args.outputs = [args.outputs]
    args.zephyr_base = find_zephyr_base()
    args.zephyr_gcc_variant = 'zephyr'
    # args.zephyr_sdk_install_dir = find_zephyr_sdk()

    make_warn_overrides(args)


def makefile_directories(app):
    '''Get paths to application and mcuboot Makefile directories for an app.

    These are returned in a dictionary, with keys 'app' and 'mcuboot'.'''
    return {'app': find_app_root(app),
            'mcuboot': find_mcuboot_root()}


def make_environments(args):
    '''Create environments for invoking make on an application.

    In general, multiple environments are needed: one for running make
    for the app itself, and another for running make on the app's
    mcuboot build.  These are returned in a dictionary, with keys 'app'
    and 'mcuboot'.'''
    app_build_env = dict(os.environ)
    for v in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
        app_build_env[v.upper()] = getattr(args, v)
    mcuboot_build_env = dict(app_build_env)
    del mcuboot_build_env['CONF_FILE']
    return {'app': app_build_env,
            'mcuboot': mcuboot_build_env}


def make_outdir(args, app, output):
    '''Get output (build) directory for an app output.'''
    return os.path.join(args.outdir, app, args.board, output)


#
# Build
#


def build_add_parser(cmd_parsers):
    build_help = 'Build Genesis application images'
    build_parser = cmd_parsers.add_parser('build', help=build_help)

    build_help_overrides = {
        '--outputs': 'Which outputs to build (default: all)'
    }
    CommonArguments.add_arguments(build_parser,
                                  help_overrides=build_help_overrides)
    build_parser.add_argument('--debug', action='store_true',
                              help='If set, print debugging output')
    build_parser.add_argument('-K', '--signing-key',
                              help='''Path to signing key for application
                                   binary. WARNING: if not given, an INSECURE
                                   default key is used which should NOT be
                                   used for production images.''')
    build_parser.add_argument('-V', '--imgtool-version',
                              help='''Image version in X.Y.Z semantic
                                   versioning format (default: {})'''.format(
                                       MCUBOOT_IMGTOOL_VERSION_DEFAULT))
    build_parser.add_argument('--skip-signature',
                              action='store_true',
                              help="""If set, don't sign the resulting binary
                                   for loading by mcuboot. Use of this option
                                   implies -o app, and is incompatible with
                                   the -K and -t options.""")


def build_version_is_semver(version):
    return re.match('^\d+[.]\d+[.]\d+$', version) is not None


def build(build_args):
    insecure_requested = False

    if build_args.skip_signature:
        if build_args.signing_key is not None:
            raise ValueError('{} is incompatible with {}'.format(
                '--skip-signature', '--signing-key'))
        build_args.outputs = 'app'
    else:
        if build_args.board not in MCUBOOT_BOARD_INFO:
            raise ValueError("Can't sign image for {}; is {} missing?".format(
                build_args.board, '--skip-signature'))
    if build_args.signing_key is None:
        build_args.signing_key = os.path.join(find_mcuboot_root(),
                                              MCUBOOT_DEV_KEY)
        insecure_requested = True
    if build_args.imgtool_version is None:
        print('No --imgtool-version specified, using {}'.format(
                  MCUBOOT_IMGTOOL_VERSION_DEFAULT),
              file=sys.stderr)
        build_args.imgtool_version = MCUBOOT_IMGTOOL_VERSION_DEFAULT
    if not build_version_is_semver(build_args.imgtool_version):
        raise ValueError('{} is not in semantic versioning format'.format(
            build_args.imgtool_version))
    make_do_overrides(build_args)

    # Run the builds.
    build_envs = make_environments(build_args)
    for app in build_args.app:
        makefile_dirs = makefile_directories(app)
        for output in build_args.outputs:
            signing_app = (output == 'app' and not build_args.skip_signature)
            outdir = make_outdir(build_args, app, output)

            # Application/mcuboot build command.
            cmd_build = ['make',
                         '-C', shlex.quote(makefile_dirs[output]),
                         '-j', str(build_args.jobs),
                         'O={}'.format(shlex.quote(outdir))]

            # Application signing command.
            if signing_app:
                vtoff = MCUBOOT_BOARD_INFO[build_args.board]['vtoff']
                word_size = MCUBOOT_BOARD_INFO[build_args.board]['word-size']
                pad = MCUBOOT_BOARD_INFO[build_args.board]['pad']
                unsigned_bin = os.path.join(outdir, 'zephyr.bin')
                app_clean = os.path.basename(app.rstrip(os.path.sep))
                signed_bin = os.path.join(
                    outdir,
                    '{}-{}-signed.bin'.format(app_clean, build_args.board))
                version = build_args.imgtool_version
                cmd_sign = ['/usr/bin/env', 'python3',
                            os.path.join(find_mcuboot_root(), IMGTOOL),
                            'sign',
                            '--key', shlex.quote(build_args.signing_key),
                            '--align', str(word_size),
                            '--header-size', str(vtoff),
                            '--included-header',
                            '--pad', str(pad),
                            '--version', shlex.quote(version),
                            shlex.quote(unsigned_bin),
                            shlex.quote(signed_bin)]

            if build_args.debug:
                print('Running build:')
                for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
                    print('\t{}={} \\'.format(b.upper(),
                                              getattr(build_args, b)))
                print('\t' + ' '.join(cmd_build))
                if signing_app:
                    print('\t' + ' '.join(cmd_sign))

            try:
                subprocess.check_call(cmd_build, env=build_envs[output])
                if signing_app:
                    subprocess.check_call(cmd_sign, env=build_envs[output])
                    if insecure_requested:
                        print('Warning: used insecure default signing key.',
                              'IMAGES ARE NOT SUITABLE FOR PRODUCTION USE.',
                              file=sys.stderr)

            except subprocess.CalledProcessError as e:
                if not build_args.keep_going:
                    sys.exit(e.returncode)


#
# Configure
#


def configure_add_parser(cmd_parsers):
    configure_help = '''Configure Genesis application images. If multiple apps
                     are given, the configurators are run in the order the apps
                     are specified.'''
    configure_parser = cmd_parsers.add_parser('configure', help=configure_help)
    CommonArguments.add_arguments(configure_parser)
    configure_parser.add_argument(
        '-C', '--configurator',
        choices=CONFIGURATORS,
        default=CONFIGURATOR_DEFAULT,
        help='Configure front-end (default: {})'.format(CONFIGURATOR_DEFAULT))


def configure(configure_args):
    make_do_overrides(configure_args)
    configure_envs = make_environments(configure_args)
    for app in configure_args.app:
        makefile_dirs = makefile_directories(app)
        for output in configure_args.outputs:
            outdir = make_outdir(configure_args, app, output)
            cmd_configure = ['make',
                             '-C', shlex.quote(makefile_dirs[output]),
                             '-j', str(configure_args.jobs),
                             'O={}'.format(shlex.quote(outdir)),
                             configure_args.configurator]
            try:
                subprocess.check_call(cmd_configure,
                                      env=configure_envs[output])
            except subprocess.CalledProcessError as e:
                if not configure_args.keep_going:
                    sys.exit(e.returncode)


#
# main()
#


def main():
    # Parsing is split into a multilevel structure based on the top-level
    # command. The first level is $scriptname [-h] $command [command_arg ...]
    top_parser = argparse.ArgumentParser()
    cmd_parsers = top_parser.add_subparsers(help='Command', dest='cmd')
    build_add_parser(cmd_parsers)
    configure_add_parser(cmd_parsers)

    args = top_parser.parse_args()
    command_handlers = {
        'build': build,
        'configure': configure
    }
    if args.cmd is None:
        commands = ', '.join(command_handlers.keys())
        print('Missing command. Choices: {}'.format(commands), file=sys.stderr)
        sys.exit(1)
    try:
        command_handlers[args.cmd](args)
    except Exception as e:
        print('Error: {}'.format(e), file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
