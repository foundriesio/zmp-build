#!/usr/bin/env python3

import argparse
import itertools
import multiprocessing
import os
import os.path
import shlex
import subprocess
import sys

#
# Globals
#

PROGRAM = sys.argv[0]
ARGV = sys.argv[1:]

# Default values for command line options.
BOARD_DEFAULT = '96b_nitrogen'
CONF_FILE_DEFAULT = 'prj.conf'
BUILD_PARALLEL_DEFAULT = multiprocessing.cpu_count()
MCUBOOT_DEV_KEY = 'root-rsa-2048.pem'     # Development-only signing key.
MCUBOOT_DEV_KEY_TYPE = 'RSA'              # Key type of development key.

# Other default values.
BUILD_DIR_DEFAULT = 'outdir'              # relative to genesis root.

# Checked out paths for important repositories relative to Genesis root.
# TODO: parse these from the repo manifest, for robustness, at some point.
ZEPHYR_PATH = 'zephyr'
ZEPHYR_SDK_PATH = os.path.join('sdk-prebuilts', 'zephyr-sdk')
MCUBOOT_PATH = 'mcuboot'

# We could be smarter about this (search for .repo, e.g.), but it seems
# unnecessary.
GENESIS_ROOT = os.path.abspath(os.path.dirname(__file__))

# Build configuration from command line options that overrides environment
# variables.
BUILD_OPTIONS = ['board', 'conf_file']
# Build configuration from internal values that overrides env. variables.
# TODO: override SDK install dir when we can provide a prebuilt repository.
BUILD_OVERRIDES = ['zephyr_base',
                   'zephyr_gcc_variant',
                   # 'zephyr_sdk_install_dir'
                   ]

# What types of build outputs to produce.
# - app: Genesis application, which can be signed for flashing or FOTA update.
# - mcuboot: Genesis bootloader, not signed and must be flashed.
BUILD_OUTPUTS = ['app', 'mcuboot']

# zep2newt.py state.
#
# FIXME: there are too many copies of this information.
#
# All of this configuration really needs to live in one place (not here), and
# to get propagated to each application and mcuboot's own build systems at
# "configuration" time.
ZEP2NEWT = os.path.join('scripts', 'zep2newt.py')
ZEP2NEWT_BOARD_INFO = {
    '96b_nitrogen': {
        'vtoff': 0x100,
        'word-size': 4,
        'pad': 0x34000,
    },

    '96b_carbon': {
        'vtoff': 0x100,
        'word-size': 1,
        'pad': 0x20000,
    },

    'frdm_k64f': {
        'vtoff': 0x200,
        'word-size': 8,
        'pad': 0x20000,
    },
}
ZEP2NEWT_KEY_TYPES = ['SHA256', 'RSA']


#
# Path management
#


def find_genesis_root():
    '''Get absolute path of root directory of this Genesis installation.'''
    return GENESIS_ROOT


def find_zephyr_base():
    '''Get absolute path of Genesis Zephyr base directory.'''
    return os.path.join(find_genesis_root(), ZEPHYR_PATH)


def find_zephyr_sdk():
    '''Get absolute path of Genesis Zephyr SDK.'''
    return os.path.join(find_genesis_root(), ZEPHYR_SDK_PATH)


def find_app_root(app_name):
    '''Get absolute path of app within Genesis Zephyr SDK.'''
    return os.path.join(find_genesis_root(), app_name)


def find_mcuboot_root():
    '''Get absolute path of mcuboot repository.'''
    return os.path.join(find_genesis_root(), MCUBOOT_PATH)


def find_default_outdir():
    '''Get absolute path of default output directory.'''
    return os.path.join(find_genesis_root(), BUILD_DIR_DEFAULT)


#
# Make helpers
#


def make_add_args(make_based_parser, help_overrides={}):
    '''Add arguments to a parser for commands which shell out to a Makefile.'''
    # These capture arguments that are needed by Zephyr makefiles, such as
    # BOARD and CONF_FILE, as well as arguments that get passed to make itself.
    # It's meant to cover the least common denominator only, depending on
    # what's needed by the script's currently handled commands.
    #
    # TODO: allow application override for things like ZEPHYR_BASE via
    # --allow-overrides option.
    arg_help = {
        'board': 'Zephyr board to target (default: {})'.format(BOARD_DEFAULT),
        'conf-file': '''App (not mcuboot) configuration file
                     (default: {})'''.format(CONF_FILE_DEFAULT),
        'jobs': '''Number of jobs to run simultaneously (default: number of
                available CPUs)''',
        'keep-going': '''If set, keep running after the first build failure.
                      Otherwise, exit on the first failure, with failing
                      command's exit code.''',
        'outdir': '''Build directory
                  (default: '{}' under Genesis root).'''.format(
                      BUILD_DIR_DEFAULT),
        'outputs': 'Which outputs to target (default: all)',
        'app': 'Genesis application(s) sources',
        }
    arg_help.update(help_overrides)

    make_based_parser.add_argument(
        '-b', '--board',
        choices=list(ZEP2NEWT_BOARD_INFO.keys()),
        default=BOARD_DEFAULT,
        help=arg_help['board'])
    make_based_parser.add_argument(
        '-c', '--conf-file',
        default=CONF_FILE_DEFAULT,
        help=arg_help['conf-file'])
    make_based_parser.add_argument(
        '-j', '--jobs',
        type=int, default=BUILD_PARALLEL_DEFAULT,
        help=arg_help['jobs'])
    make_based_parser.add_argument(
        '-k', '--keep-going',
        action='store_true',
        help=arg_help['keep-going'])
    make_based_parser.add_argument(
        '-O', '--outdir',
        default=find_default_outdir(),
        help=arg_help['outdir'])
    make_based_parser.add_argument(
        '-o', '--outputs',
        choices=BUILD_OUTPUTS + ['all'],
        default='all',
        help=arg_help['outputs'])
    make_based_parser.add_argument(
        'app', nargs='+',
        help=arg_help['app'])


def make_warn_override(args, arg):
    arg_val = getattr(args, arg)
    env_var = arg.upper()
    if env_var in os.environ and arg_val != os.environ[env_var]:
        print('Warning: overriding {}:'.format(env_var),
              file=sys.stderr)
        print('\tenvironment value: {}'.format(os.environ[env_var]),
              file=sys.stderr)
        print('\tbuilding with:     {}'.format(arg_val),
              file=sys.stderr)


def make_warn_overrides(args):
    '''Warn on values overridden from the environment.

    Looks for environment variables relevant to the Zephyr or
    application build (BOARD, etc.), and warns on values that are
    overridden by Genesis.'''
    for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
        make_warn_override(args, b)


def make_do_overrides(args):
    if args.outputs == 'all':
        args.outputs = BUILD_OUTPUTS
    else:
        args.outputs = [args.outputs]
    args.zephyr_base = find_zephyr_base()
    args.zephyr_gcc_variant = 'zephyr'
    # args.zephyr_sdk_install_dir = find_zephyr_sdk()

    make_warn_overrides(args)


def makefile_directories(app):
    '''Get paths to application and mcuboot Makefile directories for an app.

    These are returned in a dictionary, with keys 'app' and 'mcuboot'.'''
    return {'app': find_app_root(app),
            'mcuboot': find_mcuboot_root()}


def make_environments(args):
    '''Create environments for invoking make on an application.

    In general, multiple environments are needed: one for running make
    for the app itself, and another for running make on the app's
    mcuboot build.  These are returned in a dictionary, with keys 'app'
    and 'mcuboot'.'''
    app_build_env = dict(os.environ)
    for v in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
        app_build_env[v.upper()] = getattr(args, v)
    mcuboot_build_env = dict(app_build_env)
    del mcuboot_build_env['CONF_FILE']
    return {'app': app_build_env,
            'mcuboot': mcuboot_build_env}


def make_outdir(args, app, output):
    '''Get output (build) directory for an app output.'''
    return os.path.join(args.outdir, args.board, app, output)


#
# Build
#


def build(build_argv):
    insecure_requested = False

    # Build command parser.
    build_help_overrides = {'outputs': 'Which outputs to build (default: all)'}
    build_parser = argparse.ArgumentParser(
        prog=PROGRAM + ' build',
        description='Build Genesis application images')
    make_add_args(build_parser, build_help_overrides)
    build_parser.add_argument('--debug', action='store_true',
                              help='If set, print debugging output')
    build_parser.add_argument('-K', '--signing-key',
                              help='''Path to signing key for application
                                   binary. WARNING: if not given, an INSECURE
                                   default key is used which should NOT be
                                   used for production images.''')
    build_parser.add_argument('-t', '--signing-key-type',
                              choices=ZEP2NEWT_KEY_TYPES,
                              help='Key type for signing key')

    # Parse build commands and add on internal settings.
    build_args = build_parser.parse_args(build_argv)
    sk_none = build_args.signing_key is None
    skt_none = build_args.signing_key_type is None
    if sk_none ^ skt_none:
        raise ValueError('{} and {} must both be given or both omitted'.format(
            '--signing-key', '--signing-key-type'))
    if build_args.signing_key is None:
        build_args.signing_key = os.path.join(find_mcuboot_root(),
                                              MCUBOOT_DEV_KEY)
        build_args.signing_key_type = MCUBOOT_DEV_KEY_TYPE
        insecure_requested = True
    make_do_overrides(build_args)

    # Run the builds.
    build_envs = make_environments(build_args)
    for app in build_args.app:
        makefile_dirs = makefile_directories(app)
        for output in build_args.outputs:
            outdir = make_outdir(build_args, app, output)

            # Application/mcuboot build command.
            cmd_build = ['make',
                         '-C', shlex.quote(makefile_dirs[output]),
                         '-j', str(build_args.jobs),
                         'O={}'.format(shlex.quote(outdir))]

            # Application signing command.
            vtoff = ZEP2NEWT_BOARD_INFO[build_args.board]['vtoff']
            word_size = ZEP2NEWT_BOARD_INFO[build_args.board]['word-size']
            pad = ZEP2NEWT_BOARD_INFO[build_args.board]['pad']
            unsigned_bin = os.path.join(outdir, 'zephyr.bin')
            signed_bin = os.path.join(
                outdir,
                '{}-{}-signed.bin'.format(app, build_args.board))
            cmd_sign = ['/usr/bin/env', 'python3',
                        os.path.join(find_mcuboot_root(), ZEP2NEWT),
                        '--bin', shlex.quote(unsigned_bin),
                        '--key', shlex.quote(build_args.signing_key),
                        '--sig', build_args.signing_key_type,
                        '--vtoff', hex(vtoff),
                        '--word-size', str(word_size),
                        '--pad', hex(pad),
                        '--bit',
                        '--out', shlex.quote(signed_bin)]

            if build_args.debug:
                print('Running build:')
                for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
                    print('\t{}={} \\'.format(b.upper(),
                                              getattr(build_args, b)))
                print('\t' + ' '.join(cmd_build))
                if output == 'app':
                    print('\t' + ' '.join(cmd_sign))

            try:
                subprocess.check_call(cmd_build, env=build_envs[output])
                if output == 'app':
                    subprocess.check_call(cmd_sign, env=build_envs[output])
                    if insecure_requested:
                        print('Warning: used insecure default signing key.',
                              'IMAGES ARE NOT SUITABLE FOR PRODUCTION USE.',
                              file=sys.stderr)

            except subprocess.CalledProcessError as e:
                if not build_args.keep_going:
                    sys.exit(e.returncode)


#
# main()
#


def main():
    # Parsing is split into a multilevel structure based on the top-level
    # command. The first level is $scriptname [-h] $command [command_arg ...]
    top_parser = argparse.ArgumentParser(
        prog=PROGRAM,
        description="Front-end to Genesis build system",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    top_parser.add_argument('command',
                            choices=['build'],
                            help='Top level command')
    top_parser.add_argument('command_args', nargs=argparse.REMAINDER,
                            metavar='...', help='Command arguments')
    top_args = top_parser.parse_args(ARGV)

    # Dispatch to individual command handlers
    try:
        if top_args.command == 'build':
            return build(top_args.command_args)
    except ValueError as e:
        print('Error:', e.args[0], file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
