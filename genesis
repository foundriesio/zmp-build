#!/usr/bin/env python3

import abc
import argparse
import itertools
import multiprocessing
import os
import os.path
import re
import shlex
import subprocess
import sys
import time

#
# Globals
#

PROGRAM = sys.argv[0]
ARGV = sys.argv[1:]

# We could be smarter about this (search for .repo, e.g.), but it seems
# unnecessary.
GENESIS_ROOT = os.path.abspath(os.path.dirname(__file__))

# Default values shared by multiple commands.
BOARD_DEFAULT = '96b_nitrogen'
CONF_FILE_DEFAULT = 'prj.conf'
BUILD_PARALLEL_DEFAULT = multiprocessing.cpu_count()

# Checked out paths for important repositories relative to Genesis root.
# TODO: parse these from the repo manifest, for robustness, at some point.
ZEPHYR_PATH = 'zephyr'
ZEPHYR_SDK_PATH = os.path.join('sdk-prebuilts', 'zephyr-sdk')

# Build configuration from command line options that overrides environment
# variables.
BUILD_OPTIONS = ['board', 'conf_file']
# Build configuration from internal values that overrides env. variables.
# TODO: override SDK install dir when we can provide a prebuilt repository.
BUILD_OVERRIDES = ['zephyr_base',
                   'zephyr_gcc_variant',
                   # 'zephyr_sdk_install_dir'
                   ]
# What types of build outputs to produce.
# - app: Genesis application, which can be signed for flashing or FOTA update.
# - mcuboot: Genesis bootloader, not signed and must be flashed.
BUILD_OUTPUTS = ['app', 'mcuboot']
# The name of the directory which is the default root of the build hierarchy,
# relative to the .repo root.
BUILD_DIR_DEFAULT = 'outdir'

# Where mcuboot is relative to the .repo top level.
MCUBOOT_PATH = 'mcuboot'
# Development-only firmware binary signing key.
MCUBOOT_DEV_KEY = 'root-rsa-2048.pem'
# Version to write to signed binaries when none is specified.
MCUBOOT_IMGTOOL_VERSION_DEFAULT = '0.0.0'
# imgtool.py state. This post-processes binaries for chain-loading by mcuboot.
MCUBOOT_IMGTOOL = os.path.join('scripts', 'imgtool.py')
# mcuboot-related SoC-specific state.
# TODO: get these values from ZephyrExports when they're available there.
MCUBOOT_WORD_SIZES = {
    '96b_nitrogen': '4',
    '96b_carbon': '1',
    'frdm_k64f': '8',
    'nrf52840_pca10056': '4',
}

# Programs which 'configure' can use to generate Zephyr .config files.
CONFIGURATORS = ['config', 'nconfig', 'menuconfig', 'xconfig', 'gconfig',
                 'oldconfig', 'silentoldconfig', 'defconfig', 'savedefconfig',
                 'allnoconfig', 'allyesconfig', 'alldefconfig', 'randconfig',
                 'listnewconfig', 'olddefconfig']
# menuconfig is portable and the one most examples are based off of.
CONFIGURATOR_DEFAULT = 'menuconfig'


#
# Path management
#


def find_genesis_root():
    '''Get absolute path of root directory of this Genesis installation.'''
    return GENESIS_ROOT


def find_zephyr_base():
    '''Get absolute path of Genesis Zephyr base directory.'''
    return os.path.join(find_genesis_root(), ZEPHYR_PATH)


def find_zephyr_sdk():
    '''Get absolute path of Genesis Zephyr SDK.'''
    return os.path.join(find_genesis_root(), ZEPHYR_SDK_PATH)


def find_app_root(app_name):
    '''Get absolute path of app within Genesis Zephyr SDK.'''
    return os.path.join(find_genesis_root(), app_name)


def find_mcuboot_root():
    '''Get absolute path of mcuboot repository.'''
    return os.path.join(find_genesis_root(), MCUBOOT_PATH)


def find_sdk_build_root():
    '''Get absolute path to SDK build directory.'''
    return os.path.dirname(os.path.realpath(__file__))


def find_default_outdir():
    '''Get absolute path of default output directory.'''
    return os.path.join(find_genesis_root(), BUILD_DIR_DEFAULT)


def find_app_outdir(outdir, app, board, output):
    '''Get output (build) directory for an app output.'''
    return os.path.join(outdir, app, board, output)


#
# Common arguments
#


class CommonArguments(object):
    '''Helper class for arguments which are taken by multiple commands.'''

    ARG_HELP = {
        # Generally useful.
        '--board': '''Zephyr board to target
                   (default: {})'''.format(BOARD_DEFAULT),
        '--outdir': '''Build directory (default: '{}' under Genesis
                    root).'''.format(BUILD_DIR_DEFAULT),
        'app': 'Genesis application(s) sources',

        # Needed to build, configure, etc. Zephyr.
        '--conf-file': '''App (not mcuboot) configuration file
                       (default: {})'''.format(CONF_FILE_DEFAULT),
        '--jobs': '''Number of jobs to run simultaneously (default: number of
                   available CPUs)''',
        '--keep-going': '''If set, keep running after the first build failure.
                         Otherwise, exit on the first failure, with failing
                         command's exit code.''',
        '--outputs': 'Which outputs to target (default: all)',
        }

    @staticmethod
    def _whitelist(whitelist):
        if whitelist is None:
            return CommonArguments.ARG_HELP.keys()
        else:
            for arg in whitelist:
                if arg not in CommonArguments.ARG_HELP:
                    msg = 'internal error: unknown argument {}'.format(arg)
                    raise ValueError(msg)
            return whitelist

    @staticmethod
    def add_arguments(parser, help_overrides={}, whitelist=None):
        arg_help = dict(CommonArguments.ARG_HELP)
        arg_help.update(help_overrides)

        whitelist = CommonArguments._whitelist(whitelist)

        # These are generally useful for commands that operate on build
        # artifacts.
        if '--board' in whitelist:
            parser.add_argument('-b', '--board',
                                default=BOARD_DEFAULT,
                                help=arg_help['--board'])
        if '--outdir' in whitelist:
            parser.add_argument('-O', '--outdir',
                                default=find_default_outdir(),
                                help=arg_help['--outdir'])
        if 'app' in whitelist:
            parser.add_argument('app', nargs='+', help=arg_help['app'])

        # These are needed by commands that invoke 'make', like 'build' and
        # 'configure'.
        if '--conf-file' in whitelist:
            parser.add_argument('-c', '--conf-file',
                                default=CONF_FILE_DEFAULT,
                                help=arg_help['--conf-file'])
        if '--jobs' in whitelist:
            parser.add_argument('-j', '--jobs',
                                type=int, default=BUILD_PARALLEL_DEFAULT,
                                help=arg_help['--jobs'])
        if '--keep-going' in whitelist:
            parser.add_argument('-k', '--keep-going',
                                action='store_true',
                                help=arg_help['--keep-going'])
        if '--outputs' in whitelist:
            parser.add_argument('-o', '--outputs',
                                choices=BUILD_OUTPUTS + ['all'],
                                default='all',
                                help=arg_help['--outputs'])


#
# Zephyr build system glue
#


class ZephyrExports(object):
    """Represents exported variables from a Zephyr build.
    """

    EXPORT = 'Makefile.export'
    HELPER = 'print-value.mk'

    def __init__(self, output_dir):
        self.output_dir = output_dir

    def get(self, variable):
        """Return the value of a Zephyr build variable."""
        export_path = os.path.join(self.output_dir, ZephyrExports.EXPORT)
        helper_path = os.path.join(find_sdk_build_root(), ZephyrExports.HELPER)
        cmd_print_val = ['make',
                         '-f', shlex.quote(export_path),
                         '-f', shlex.quote(helper_path),
                         shlex.quote('print-{}'.format(variable))]
        try:
            value = subprocess.check_output(cmd_print_val,
                                            stderr=subprocess.DEVNULL)
            return str(value, 'utf-8').strip()
        except subprocess.CalledProcessError as e:
            msg = "{} is missing or empty in {}".format(variable, export_path)
            raise ValueError(msg)

    def get_ensure_int(self, variable):
        """Return the value of a Zephyr build variable as a string,
        after ensuring it is an integer."""
        return str(int(self.get(variable), base=0))

    def get_ensure_hex(self, variable):
        """Return the value of a Zephyr build variable as a hex string,
        after ensuring it is an integer."""
        return hex(int(self.get(variable), base=0))


class ZephyrBinaryFlasher(abc.ABC):

    @staticmethod
    def create_flasher(flash_args):
        '''Get a flasher instance suited to the configuration given in
        flash_args.'''
        app_outdir = find_app_outdir(flash_args.outdir, flash_args.app,
                                     flash_args.board, 'app')
        exports = ZephyrExports(app_outdir)
        flash_script = exports.get('FLASH_SCRIPT')

        for sub_cls in ZephyrBinaryFlasher.__subclasses__():
            if sub_cls.is_equivalent_to(flash_script):
                return sub_cls()
        msg = 'no supported flasher equivalent to {}'.format(flash_script)
        raise ValueError(msg)

    @staticmethod
    @abc.abstractmethod
    def is_equivalent_to(zephyr_flash_script):
        '''Check if this flasher is also able to flash the same types of
        boards as a FLASH_SCRIPT in the Zephyr build system.'''

    @abc.abstractmethod
    def do_flash(self, flash_args, exports, mcuboot_quoted, app_quoted,
                 app_offset, extra_quoted):
        '''Low-level flash routine.'''

    def _get_flash_common(self, flash_args):
        app_outdir = find_app_outdir(flash_args.outdir, flash_args.app,
                                     flash_args.board, 'app')
        # It's fine to use the app's exports to flash mcuboot as well.
        exports = ZephyrExports(app_outdir)
        app_offset = hex(int(exports.get('FLASH_AREA_IMAGE_0_OFFSET'), base=0))
        app_basename = os.path.basename(flash_args.app)
        app_bin = '{}-{}-signed.bin'.format(app_basename, flash_args.board)
        app_quoted = shlex.quote(os.path.join(app_outdir, app_bin))

        mcuboot_outdir = find_app_outdir(flash_args.outdir, flash_args.app,
                                         flash_args.board, 'mcuboot')
        mcuboot_quoted = shlex.quote(os.path.join(mcuboot_outdir,
                                                  'zephyr.bin'))

        extra_quoted = [shlex.quote(e) for e in flash_args.extra]

        return (exports, mcuboot_quoted, app_quoted, app_offset, extra_quoted)

    def flash(self, flash_args):
        '''Flash an image to a board, given the configuration in flash_args.'''
        e, mq, aq, ao, eq = self._get_flash_common(flash_args)
        self.do_flash(flash_args, e, mq, aq, ao, eq)


class DfuUtilBinaryFlasher(ZephyrBinaryFlasher):

    def do_flash(self, flash_args, exports, mcuboot_quoted, app_quoted,
                 app_offset, extra_quoted):
        # TODO: support non-DfuSe devices. As-is, we support STM32 extensions
        # to the DFU protocol only.
        #
        # We ignore DFUUTIL_DFUSE_ADDR since we're doing a dual-image flash.
        flash_base = exports.get_ensure_hex('CONFIG_FLASH_BASE_ADDRESS')
        app_offset = exports.get_ensure_int('FLASH_AREA_IMAGE_0_OFFSET')
        app_base = hex(int(flash_base, base=16) + int(app_offset))
        pid = exports.get('DFUUTIL_PID')
        pid_arg_quoted = '[{}]'.format(shlex.quote(pid))

        cmd_flash_mcuboot = ['dfu-util',
                             '-d', pid_arg_quoted,
                             '-a', '0',
                             '-s', '{}:force:mass-erase'.format(flash_base),
                             '-D', mcuboot_quoted]
        if flash_args.debug:
            print('Flashing mcuboot:')
            print('\t{}'.format(' '.join(cmd_flash_mcuboot)))
        subprocess.check_call(cmd_flash_mcuboot)

        cmd_flash_app = ['dfu-util',
                         '-d', pid_arg_quoted,
                         '-a', '0',
                         '-s', '{}:leave'.format(app_base),
                         '-D', app_quoted]
        if flash_args.debug:
            print('Flashing signed application:')
            print('\t{}'.format(' '.join(cmd_flash_app)))
        subprocess.check_call(cmd_flash_app)

    def is_equivalent_to(script):
        return script == 'dfuutil.sh'


class PyOcdBinaryFlasher(ZephyrBinaryFlasher):

    # Invoking pyocd-flashtool again quickly results in errors on some systems.
    SLEEP_INTERVAL_SEC = 0.75

    def do_flash(self, flash_args, exports, mcuboot_quoted, app_quoted,
                 app_offset, extra_quoted):
        target_quoted = shlex.quote(exports.get('PYOCD_TARGET'))

        cmd_flash_mcuboot = (['pyocd-flashtool',
                              '-t', target_quoted,
                              '-ce',
                              '-a', '0x0'] +
                             extra_quoted +
                             [mcuboot_quoted])
        if flash_args.debug:
            print('Flashing mcuboot:')
            print('\t{}'.format(' '.join(cmd_flash_mcuboot)))
        subprocess.check_call(cmd_flash_mcuboot)

        time.sleep(PyOcdBinaryFlasher.SLEEP_INTERVAL_SEC)

        cmd_flash_app = (['pyocd-flashtool',
                          '-t', target_quoted,
                          '-a', app_offset] +
                         extra_quoted +
                         [app_quoted])
        if flash_args.debug:
            print('Flashing signed application:')
            print('\t{}'.format(' '.join(cmd_flash_app)))
        subprocess.check_call(cmd_flash_app)

    def is_equivalent_to(script):
        return script == 'pyocd.sh'


#
# Make helpers
#


def make_warn_override(args, arg):
    arg_val = getattr(args, arg)
    env_var = arg.upper()
    if env_var in os.environ and arg_val != os.environ[env_var]:
        print('Warning: overriding {}:'.format(env_var),
              file=sys.stderr)
        print('\tenvironment value: {}'.format(os.environ[env_var]),
              file=sys.stderr)
        print('\tbuilding with:     {}'.format(arg_val),
              file=sys.stderr)


def make_warn_overrides(args):
    '''Warn on values overridden from the environment.

    Looks for environment variables relevant to the Zephyr or
    application build (BOARD, etc.), and warns on values that are
    overridden by Genesis.'''
    for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
        make_warn_override(args, b)


def make_do_overrides(args):
    if args.outputs == 'all':
        args.outputs = BUILD_OUTPUTS
    else:
        args.outputs = [args.outputs]
    args.zephyr_base = find_zephyr_base()
    args.zephyr_gcc_variant = 'zephyr'
    # args.zephyr_sdk_install_dir = find_zephyr_sdk()

    make_warn_overrides(args)


def makefile_directories(app):
    '''Get paths to application and mcuboot Makefile directories for an app.

    These are returned in a dictionary, with keys 'app' and 'mcuboot'.'''
    return {'app': find_app_root(app),
            'mcuboot': find_mcuboot_root()}


def make_environments(args):
    '''Create environments for invoking make on an application.

    In general, multiple environments are needed: one for running make
    for the app itself, and another for running make on the app's
    mcuboot build.  These are returned in a dictionary, with keys 'app'
    and 'mcuboot'.'''
    app_build_env = dict(os.environ)
    for v in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
        app_build_env[v.upper()] = getattr(args, v)
    mcuboot_build_env = dict(app_build_env)
    del mcuboot_build_env['CONF_FILE']
    return {'app': app_build_env,
            'mcuboot': mcuboot_build_env}


#
# Build
#


def build_add_parser(cmd_parsers):
    build_help = 'Build Genesis application images'
    build_parser = cmd_parsers.add_parser('build', help=build_help)

    build_help_overrides = {
        '--outputs': 'Which outputs to build (default: all)'
    }
    CommonArguments.add_arguments(build_parser,
                                  help_overrides=build_help_overrides)
    build_parser.add_argument('-K', '--signing-key',
                              help='''Path to signing key for application
                                   binary. WARNING: if not given, an INSECURE
                                   default key is used which should NOT be
                                   used for production images.''')
    build_parser.add_argument('-V', '--imgtool-version',
                              help='''Image version in X.Y.Z semantic
                                   versioning format (default: {})'''.format(
                                       MCUBOOT_IMGTOOL_VERSION_DEFAULT))
    build_parser.add_argument('--skip-signature',
                              action='store_true',
                              help="""If set, don't sign the resulting binary
                                   for loading by mcuboot. Use of this option
                                   implies -o app, and is incompatible with
                                   the -K and -t options.""")


def build_sign_command(build_args, outdir, app):
    exports = ZephyrExports(outdir)
    vtoff = exports.get_ensure_hex('CONFIG_TEXT_SECTION_OFFSET')
    pad = exports.get_ensure_hex('FLASH_AREA_IMAGE_0_SIZE')
    unsigned_bin = os.path.join(outdir, 'zephyr.bin')
    app_clean = os.path.basename(app.rstrip(os.path.sep))
    signed_bin = os.path.join(outdir,
                              '{}-{}-signed.bin'.format(app_clean,
                                                        build_args.board))
    version = build_args.imgtool_version
    return ['/usr/bin/env', 'python3',
            os.path.join(find_mcuboot_root(), MCUBOOT_IMGTOOL),
            'sign',
            '--key', shlex.quote(build_args.signing_key),
            '--align', MCUBOOT_WORD_SIZES[build_args.board],
            '--header-size', vtoff,
            '--included-header',
            '--pad', pad,
            '--version', shlex.quote(version),
            shlex.quote(unsigned_bin),
            shlex.quote(signed_bin)]


def build_version_is_semver(version):
    return re.match('^\d+[.]\d+[.]\d+$', version) is not None


def build(build_args):
    insecure_requested = False

    if build_args.skip_signature:
        if build_args.signing_key is not None:
            raise ValueError('{} is incompatible with {}'.format(
                '--skip-signature', '--signing-key'))
        build_args.outputs = 'app'
    else:
        if build_args.board not in MCUBOOT_WORD_SIZES:
            raise ValueError("unknown flash word size for {}".format(
                build_args.board))
    if build_args.signing_key is None:
        build_args.signing_key = os.path.join(find_mcuboot_root(),
                                              MCUBOOT_DEV_KEY)
        insecure_requested = True
    if build_args.imgtool_version is None:
        print('No --imgtool-version specified, using {}'.format(
                  MCUBOOT_IMGTOOL_VERSION_DEFAULT),
              file=sys.stderr)
        build_args.imgtool_version = MCUBOOT_IMGTOOL_VERSION_DEFAULT
    if not build_version_is_semver(build_args.imgtool_version):
        raise ValueError('{} is not in semantic versioning format'.format(
            build_args.imgtool_version))
    make_do_overrides(build_args)

    # Run the builds.
    build_envs = make_environments(build_args)
    for app in build_args.app:
        makefile_dirs = makefile_directories(app)
        for output in build_args.outputs:
            signing_app = (output == 'app' and not build_args.skip_signature)
            outdir = find_app_outdir(build_args.outdir, app,
                                     build_args.board, output)

            # Application/mcuboot build command.
            #
            # The Zephyr build's output exports are useful during the build for
            # signing images, and also afterwards, e.g. when deciding how to
            # flash the binaries.
            cmd_build = ['make',
                         '-C', shlex.quote(makefile_dirs[output]),
                         '-j', str(build_args.jobs),
                         'O={}'.format(shlex.quote(outdir))]
            cmd_exports = cmd_build + ['outputexports']

            try:
                if build_args.debug:
                    print('Building Zephyr:')
                    for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
                        print('\t{}={} \\'.format(b.upper(),
                                                  getattr(build_args, b)))
                    print('\t' + ' '.join(cmd_build))
                subprocess.check_call(cmd_build, env=build_envs[output])
                if build_args.debug:
                    print('Generating outputexports:')
                    for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
                        print('\t{}={} \\'.format(b.upper(),
                                                  getattr(build_args, b)))
                    print('\t' + ' '.join(cmd_exports))
                subprocess.check_call(cmd_exports, env=build_envs[output])
                # Note: generating the signing command requires some Zephyr
                # build outputs.
                if signing_app:
                    cmd_sign = build_sign_command(build_args, outdir, app)
                    if build_args.debug:
                        print('Signing application binary:')
                        print('\t' + ' '.join(cmd_sign))
                    subprocess.check_call(cmd_sign, env=build_envs[output])
                    if insecure_requested:
                        print('Warning: used insecure default signing key.',
                              'IMAGES ARE NOT SUITABLE FOR PRODUCTION USE.',
                              file=sys.stderr)

            except subprocess.CalledProcessError as e:
                if not build_args.keep_going:
                    sys.exit(e.returncode)


#
# Configure
#


def configure_add_parser(cmd_parsers):
    configure_help = '''Configure Genesis application images. If multiple apps
                     are given, the configurators are run in the order the apps
                     are specified.'''
    configure_parser = cmd_parsers.add_parser('configure', help=configure_help)
    CommonArguments.add_arguments(configure_parser)
    configure_parser.add_argument(
        '-C', '--configurator',
        choices=CONFIGURATORS,
        default=CONFIGURATOR_DEFAULT,
        help='Configure front-end (default: {})'.format(CONFIGURATOR_DEFAULT))


def configure(configure_args):
    make_do_overrides(configure_args)
    configure_envs = make_environments(configure_args)
    for app in configure_args.app:
        makefile_dirs = makefile_directories(app)
        for output in configure_args.outputs:
            outdir = find_app_outdir(configure_args.outdir, app,
                                     configure_args.board, output)
            cmd_configure = ['make',
                             '-C', shlex.quote(makefile_dirs[output]),
                             '-j', str(configure_args.jobs),
                             'O={}'.format(shlex.quote(outdir)),
                             configure_args.configurator]
            try:
                if configure_args.debug:
                    print('Configuring build:')
                    for b in itertools.chain(BUILD_OPTIONS, BUILD_OVERRIDES):
                        print('\t{}={} \\'.format(b.upper(),
                                                  getattr(configure_args, b)))
                    print('\t' + ' '.join(cmd_configure))
                subprocess.check_call(cmd_configure,
                                      env=configure_envs[output])
            except subprocess.CalledProcessError as e:
                if not configure_args.keep_going:
                    sys.exit(e.returncode)


#
# Flash
#


def flash_add_parser(cmd_parsers):
    flash_help = 'Flash a bootloader and a signed application image to a board'
    flash_parser = cmd_parsers.add_parser('flash', help=flash_help)
    flash_whitelist = {'--board', '--outdir', 'app'}
    CommonArguments.add_arguments(flash_parser, whitelist=flash_whitelist)
    flash_parser.add_argument('-e', '--extra', default='',
                              help='''Extra arguments to pass to the
                                   flashing script''')


def flash(flash_args):
    if len(flash_args.app) > 1:
        raise ValueError('only one application may be flashed at a time.')
    flash_args.app = flash_args.app[0].rstrip(os.path.sep)
    flash_args.extra = flash_args.extra.split()

    flasher = ZephyrBinaryFlasher.create_flasher(flash_args)
    flasher.flash(flash_args)


#
# main()
#


def main():
    # Parsing is split into a multilevel structure based on the top-level
    # command. The first level is $scriptname [-h] $command [command_arg ...]
    top_parser = argparse.ArgumentParser()
    top_parser.add_argument('--debug', default=False, action='store_true',
                            help='If set, print extra debugging information.')
    cmd_parsers = top_parser.add_subparsers(help='Command', dest='cmd')
    build_add_parser(cmd_parsers)
    configure_add_parser(cmd_parsers)
    flash_add_parser(cmd_parsers)

    args = top_parser.parse_args()
    command_handlers = {
        'build': build,
        'configure': configure,
        'flash': flash,
    }
    if args.cmd is None:
        commands = ', '.join(command_handlers.keys())
        print('Missing command. Choices: {}'.format(commands), file=sys.stderr)
        sys.exit(1)
    try:
        command_handlers[args.cmd](args)
    except Exception as e:
        if args.debug:
            raise
        else:
            re_run = '"{} --debug {} ..."'.format(PROGRAM, args.cmd)
            print('Error: {}'.format(e), file=sys.stderr)
            print('Re-run as {} for a stack trace.'.format(re_run),
                  file=sys.stderr)


if __name__ == '__main__':
    main()
